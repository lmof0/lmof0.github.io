<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>a website: gravity</title>
<link href="../math.css" rel="stylesheet" type="text/css">
<!--
todo: fix trails acting odd with reference frames/high velocities/high timesteps
-->
<style>
html {
	width: 100%;
	height: 100%;
}
body {
	background: #000;
	margin:0;
	overflow:hidden;
	height: 100%;
	color:#fff;
	font-family:times;
}
canvas {
	image-rendering: crisp-edges;
}
abbr {
	cursor:help;
}
.inline {display:inline;}
.hidden {display:none;}
.noselect {user-select:none;}
::selection {
	color: #ffffff;
	background: #333333;
}

/* ortiel */
#wrap
{
	display:table;
	width:100%;
	height:100%;
	margin-bottom:-96px;
	min-height:96px;
}
#wrapped-wrap
{
	width:100%;
	display:table-cell;
	vertical-align:middle;
	text-align:center;
}
/* ortieial ende */
#yz-rot-setting {
	height:15px;
	margin:0px;
	vertical-align:middle;
}
.info-box {
	border:4px solid #fff;
	color:#fff;
	width:320px;
	font-family:initial;
	padding:4px;
	background-color:#000;
	text-align:left;
	border-radius:2px;
	margin-bottom:5px;
}
.info-parameter {
	/*user-select: none;*/
	color: #fff;
	font-family:ms ui gothic, monospace;
	display:inline;
	color:#0f0;
}
.blue {color:#00f;}
.white {color:#fff;}
.white-glow {color:#fff;text-shadow: 0px 0px 2px #fff;}
button.toggle-motion {
	position: fixed; /* armenian */
	right: 10px;
	bottom: 10px;
	font-size: 1.0em;
	font-family: Garamond;
	color: #0ff;
	background: #0007;
	cursor: pointer;
	border: 1.6px white outset;
}
button.toggle-motion:active {
	border: 1.6px white inset;
}
</style>

</head>
<body>
<a href="../index.html" style="position:absolute;left:10px;bottom:10px;">back</a>
	<div style="position:absolute;left:10px;top:10px;font-size:2em;color:#f00;">ps this is like hugley wip please check back frequently for updates</div>

<div id="wrap"><div id="wrapped-wrap">
<canvas id="canvas" width="600" height="480" style="border:1px solid #fff;transform: scale(80%);" onwheel="zoom_screen(event)" onmousemove="update_mouse_pos(event)">
Your browser does not support the HTML canvas tag.</canvas>

<div style="top:-40px;position:relative;text-align:center;color:#aaa;text-shadow:0px 0px 2px #fff;display:table;width:100%;font-family:ms ui gothic;font-size:16px;">
<div style="width:481.28px;display:inline-block;text-align:left;">
<div style="width:200%;display:inline-block;"> <!-- i don't not dislike this solution -->
simulation time: <div id="simulation-time-indicator" class="inline"></div>
</div></div></div>

</div></div>

<div style="width:fit-content;height:600px;right:40px;top:40px;display:inline;position:absolute;margin:10px;overflow-y:scroll;">
	<div id="settings" class="info-box">
		<details open>
		<summary class="noselect settings-title" style="cursor:pointer;padding-left:3px;"><div style="text-align:center;position:absolute;display:inline;width:100%;left:0px;">settings</div></summary>
		<br>
		<label for="trails-setting">trails enabled: </label>
		<input type="checkbox" id="trails-setting" name="trails-setting" value="trails-setting"><br>
		<label for="labels-setting">labels enabled: </label>
		<input type="checkbox" id="labels-setting" name="labels-setting" value="labels-setting"><br>
		<label for="yz-rot-setting">y-z rotation: </label>
		<input type="range" id="yz-rot-setting" name="yz-rot-setting"><div id="yz-rot-indicator" style="display:inline;">&emsp;0 rad</div>
		</details>
	</div>
	
	<div id="body_info" class="info-box" style="border:4px solid #777;color:#ccc;">
		<details open>
		<summary class="noselect settings-title" style="cursor:pointer;padding-left:3px;"><div style="text-align:center;position:absolute;display:inline;width:100%;left:0px;color:#fff;">body info</div></summary>
		<br>
		<div id="info-floating" class="">click on a planet/moon/star/whatever to get info about it! if you're lucky it will also have a human-written description to go along! if it doesn't, you can write one yourself.</div>
		<div id="info-body" class="hidden">
			name: <div id="info-body-name" class="inline white-glow"></div><br>
			orbital parent: <div id="info-body-parent" class="inline white-glow"></div><br>
			<details open>
			<summary class="noselect" style="color:#fff;">physical properties</summary>
				radius: <div id="info-body-radius" class="info-parameter white"></div> <br>
				mass: <div id="info-body-mass" class="info-parameter white"></div> <br>
				color: <div id="info-body-color" class="info-parameter white"></div> <br>
				<!--position: <div id="info-body-position" class="info-parameter" style="color:#fff;"></div><br>
				velocity: <div id="info-body-velocity" class="info-parameter" style="color:#fff;"></div><br>-->
			</details>
			<details open>
			<summary class="noselect" style="color:#fff;">orbital parameters</summary>
				<abbr title="Time of measurement">epoch:</abbr> <div id="info-body-epoch" class="info-parameter" style="color:#fff;"></div> <br>
				<abbr title="Semi-major axis">SMA:</abbr> <div id="info-body-sma" class="info-parameter"></div> <br>
				<abbr title="Eccentricity">ecc:</abbr> <div id="info-body-ecc" class="info-parameter"></div> <br>
				<abbr title="Inclination">inc:</abbr> <div id="info-body-inc" class="info-parameter"></div> <br>
				<abbr title="Argument of Pericenter"><m>&omega;</m>:</abbr> <div id="info-body-arg-per" class="info-parameter"></div> <br>
				<abbr title="Longitude of the Ascending Node"><m>&Omega;</m>:</abbr> <div id="info-body-lon-asc" class="info-parameter"></div> <br>
				<abbr title="Mean Anomaly">M:</abbr> <div id="info-body-mean-anomaly" class="info-parameter"></div> <br>
				<abbr title="True Anomaly"><m>&nu;</m>:</abbr> <div id="info-body-true-anomaly" class="info-parameter blue"></div> <br>
				<abbr title="Orbital Period"><m>T</m>:</abbr> <div id="info-body-orbital-period" class="info-parameter blue"></div> <br>
				<abbr title="Speed"><m>v</m>:</abbr> <div id="info-body-speed" class="info-parameter blue"></div> <br>
				<abbr title="Speed from the reference frame of the parent body"><m>v<sub>rel</sub></m>:</abbr> <div id="info-body-relative-speed" class="info-parameter blue"></div> <br>
				dist. to parent:</abbr> <div id="info-body-distance-to-parent" class="info-parameter blue"></div> <br>
			</details>
			<textarea id="info-body-desc" style="width:90%;height:8em;font-size:14px;border:1px solid #555555;color:#aaffaa;font-family:ms gothic, monospace;padding:4px;margin:2px;overflow-y:auto;resize:none;background-color: #000000;cursor:auto;"></textarea><br>
		</div>
		</details>
	</div>
	
	<div id="create_body" class="info-box" style="border:4px solid #00f;">
		<details>
		<summary class="noselect settings-title" style="cursor:pointer;padding-left:3px;"><div style="text-align:center;position:absolute;display:inline;width:100%;left:0px;">create body</div></summary>
		<br>
		todo :^)
		</details>
	</div>
</div>

<div style="bottom:10px;position:absolute;text-align:center;color:#aaa;text-shadow:0px 0px 2px #aaa;display:table;width:100%;">
<div style="width:481.28px;display:inline-block;text-align:left;">
use wasd or arrows to pan the camera. click on an object to follow it. [f] speeds up time and [r] slows it down.
</div>
</div>

<button class="toggle-motion" id="toggle-motion">toggle motion</button>

<script>
let canvas = document.getElementById("canvas");
let ctx = canvas.getContext("2d");
const G = 6.67430 * 10**-11; // m^3*kg^-1*s^-2 = N*m^2*kg^-2 ==> force times area per two masses (i'm sure that makes sense)
function lerp(a,b,f) {
	return (b-a)*f+a;
}
function vec_add(U,V) {return [U[0] + V[0], U[1] + V[1], U[2] + V[2]];}
function vec_sub(U,V) {return [U[0] - V[0], U[1] - V[1], U[2] - V[2]];}
function vec_div(U,s) {return [U[0] / s, U[1] / s, U[2] / s];}
function vec_mul(U,s) {return [U[0] * s, U[1] * s, U[2] * s];}
function vec_neg(U) {return [-U[0], -U[1], -U[2]];}
function vec_lerp(V,U,f) { // VUF!!!! VUFFY!!!!
	return [lerp(V[0],U[0],f), lerp(V[1],U[1],f), lerp(V[2],U[2],f)];
}
function deg(angle) {return angle/180*Math.PI;} // turns degrees into radians, for ecliptic trig use/usage

let bodies = [];
class Body {
	constructor(name, color, mass, radius, pos=[0,0,0], vel=[0,0,0], is_tiny=false) {
		this.id = bodies.length;
		this.name = name;
		this.color = color;
		//this.info = info;
		this.mass = mass; // kg
		this.radius = radius;
		this.pos = pos; // [x,y,z] m
		this.vel = vel; // [x,y,z] m/s
		this.is_tiny = is_tiny;
		this.desc = "there's no description for this object!";
		/*
		wawawasdwasdAJwrna
		sfg gjeia jI Tjdwa

		d
		a
		s
		*/
		
		this.parent = neutral_reference;
		
		bodies.push(this);
	}
	/*kepler_te(parent, sma, ecc, inc, omega_arg_per, omega_lon_asc, mean_anomaly, time, epoch) {
		this.kepler(parent, sma, ecc, inc, omega_arg_per, omega_lon_asc, Math.sqrt((G*parent.mass)/sma**3)*(time-epoch));
	}*/
	kepler(parent, sma, ecc, inc, omega_arg_per, omega_lon_asc, mean_anomaly, time, epoch) {
		this.parent = parent; // makeshift
		// all of this is makeshift i apologize
		// mu = G * mass
		let mu = G * parent.mass; // gravitational parameter
		//let n = Math.sqrt(mu/sma**3);
		let mean_anomaly_at_t = mean_anomaly;
		if (time != epoch) {
			let delta_t = (time - epoch);
			//console.log(this.name+": "+delta_t);
			mean_anomaly_at_t = mean_anomaly + delta_t*Math.sqrt(mu / (sma**3));
			mean_anomaly_at_t %= Math.PI*2;
			//console.log(mean_anomaly_at_t);
			//console.log(mean_anomaly);
		}
		
		// here we go again
		// mostly using ComputeStateVectors() from http://orbitsimulator.com/gsim.html at line 9312
		let m = this.mass + parent.mass;
		let ecc_anomaly = mean_anomaly_at_t + ecc / 2;
		let delta = 1;
		let epsilon = 1e-9;
		let e1 = 0;
		let i = 0;
		let max_iter = 30;
		while (delta > epsilon && i < max_iter) {
			e1 = ecc_anomaly - (ecc_anomaly - ecc * Math.sin(ecc_anomaly) - mean_anomaly_at_t) / (1 - ecc * Math.cos(ecc_anomaly));
			delta = Math.abs(e1 - ecc_anomaly);
			ecc_anomaly = e1;
		}
		
		let cos_ecc_anomaly = Math.cos(ecc_anomaly);
		let sin_ecc_anomaly = Math.sin(ecc_anomaly);
		e1 = sma * Math.sqrt(Math.abs(1 - ecc**2));
		let xw = sma * (cos_ecc_anomaly - ecc);
		let yw = e1 * sin_ecc_anomaly;
		
		let edot = Math.sqrt((G * m) / sma) / (sma * (1 - ecc * cos_ecc_anomaly));
		let xdw = -sma * edot * sin_ecc_anomaly;
		let ydw = e1 * edot * cos_ecc_anomaly;
		
		let cosw = Math.cos(omega_arg_per);
		let sinw = Math.sin(omega_arg_per);
		let coso = Math.cos(omega_lon_asc);
		let sino = Math.sin(omega_lon_asc);
		let cosi = Math.cos(inc);
		let sini = Math.sin(inc);
		let swci = sinw * cosi;
		let cwci = cosw * cosi;
		let p_x = cosw * coso - sino * swci;
		let p_y = cosw * sino + coso * swci;
		let p_z = sinw * sini;
		let q_x = -sinw * coso - sino * cwci;
		let q_y = -sinw * sino + coso * cwci;
		let q_z = cosw * sini;
		
		let X = xw * p_x + yw * q_x;
		let Y = xw * p_y + yw * q_y;
		let Z = xw * p_z + yw * q_z;
		let V_X = xdw * p_x + ydw * q_x;
		let V_Y = xdw * p_y + ydw * q_y;
		let V_Z = xdw * p_z + ydw * q_z;
		
		/*let Mt = mean_anomaly;//n*(time - epoch); // mean anomaly (at time t?)
		// MA = EA - ecc*sin(EA)
		// -ecc*sin(EA) = MA - EA
		// sin(EA) = -(MA - EA)/ecc
		// sin(EA) = (EA - MA)/ecc
		// EA = arcsin((EA - MA)/ecc)
		// this next block of code, ending at the end of the while loop, supposedly solves for eccentric anomaly (EA)
		// given the mean anomaly and the eccentricity. plug and pray
		let EA = Mt;
		let F = EA - ecc * Math.sin(EA) - Mt;
		let i = 0;
		let max_iter = 30;
		while (Math.abs(F) > 1e-9 && i < max_iter) {
			EA = EA - F / (1 - ecc*Math.cos(ecc));
			F = EA - ecc*Math.sin(EA) - Mt;
			i++;
		}
		
		let nu = 2 * Math.atan(((1+ecc)/(1-ecc))**.5 * Math.tan(EA/2))
		let r = sma*(1-ecc*Math.cos(nu));
		let h = (mu*sma * (1 - ecc**2))**.5;
		
		let lan = omega_lon_asc; // longitude of ascending node, Capital Omega, Om
		let arp = omega_arg_per; // argument of periapsis, lowercase omega, w
		
		let X = r*(Math.cos(lan)*Math.cos(arp+nu) - Math.sin(lan)*Math.sin(arp+nu)*Math.cos(inc));
		let Y = r*(Math.cos(lan)*Math.cos(arp+nu) + Math.sin(lan)*Math.sin(arp+nu)*Math.cos(inc));
		let Z = r*(Math.sin(inc)*Math.sin(arp+nu));
		
		let p = sma*(1-ecc**2);
		let V_X = (X*h*ecc/(r*p))*Math.sin(nu) - (h/r)*(Math.cos(lan)*Math.sin(arp+nu) + Math.sin(lan)*Math.cos(arp+nu)*Math.cos(inc));
		let V_Y = (X*h*ecc/(r*p))*Math.sin(nu) - (h/r)*(Math.sin(lan)*Math.sin(arp+nu) - Math.cos(lan)*Math.cos(arp+nu)*Math.cos(inc));
		let V_Z = (Z*h*ecc/(r*p))*Math.sin(nu) + (h/r)*(Math.cos(arp+nu)*Math.sin(inc));*/
		/*
		let R = (this.pos[0]**2+this.pos[1]**2+this.pos[2]**2)**.5;
		let V = (this.vel[0]**2+this.vel[1]**2+this.vel[2]**2)**.5;
		
		let specE = (V**2/2) - (mu/R);
		let a = -mu / (2*specE);
		a = -mu / (2*(V**2/2 - mu/R))
		a = -mu / (V**2 - 2mu/R)
		a(V**2 - 2mu/R) = -mu
		aV**2 - 2amu/R = -mu
		V**2 - 2mu/R = -mu/a
		V**2 = 2mu/R - mu/a
		
		in other words:
		||V|| = (mu/sma)**.5, for e = 0
		||P|| = sma, for e = 0
		*/
		this.pos = vec_add([X,Y,Z],parent.pos);//this.pos = [sma,0,0];
		this.vel = vec_add([V_X, V_Y, V_Z],parent.vel);//this.vel = [0,-((2*mu/sma - mu/sma)**.5),0];
		// R (pos vec magn) = (a(1-e^2))/(1 + e(cos(nu)))
		// where a is the semimajor axis, e is eccentricity, and nu is true anomaly.
		
		// e_vec = (1/mu)((V^2 - (mu/R))R_vec-(R_vec dot V_vec)V_vec)
		// e_vec, the eccentricity vector
		// mu, gravitational parameter
		// V_vec, vel vector
		// R_vec, pos vector
		// V, magn of V_vec
		// R, magn of R_vec
	}
	
	get_osculating_elements() { // i'm just gonna assume that that's what the instantaneous keplerian elements are called
		let mu = this.parent.mass * G;
		
		let Ri = this.pos[0]-this.parent.pos[0];
		let Rj = this.pos[1]-this.parent.pos[1];
		let Rk = this.pos[2]-this.parent.pos[2];
		let Vi = this.vel[0]-this.parent.vel[0];
		let Vj = this.vel[1]-this.parent.vel[1];
		let Vk = this.vel[2]-this.parent.vel[2];
		
		if (Ri == 0) Ri = 1e-12;
		if (Rj == 0) Rj = 1e-12;
		if (Rk == 0) Rk = 1e-12;
		if (Vi == 0) Vi = 1e-12;
		if (Vj == 0) Vj = 1e-12;
		if (Vk == 0) Vk = 1e-12;
		
		let R = Math.sqrt(Ri**2 + Rj**2 + Rk**2);
		let V = Math.sqrt(Vi**2 + Vj**2 + Vk**2);
		
		let specE = (V**2 / 2) - (mu / R);
		
		let sma = -mu / (2*specE);
		
		let RdotV = (Ri * Vi) + (Rj * Vj) + (Rk * Vk);
		let Ei = (1 / mu) * (((V*V) - (mu / R)) * Ri - (RdotV * Vi));
		let Ej = (1 / mu) * (((V*V) - (mu / R)) * Rj - (RdotV * Vj));
		let Ek = (1 / mu) * (((V*V) - (mu / R)) * Rk - (RdotV * Vk));
		
		let ecc = Math.sqrt(Ei**2 + Ej**2 + Ek**2);
		
		let Hi = (Rj * Vk) - (Vj * Rk);
		let Hj = -(Ri * Vk) - (Vi * Rk);
		let Hk = (Ri * Vj) - (Vi * Rj);
		
		let h = Math.sqrt(Hi**2 + Hj**2 + Hk**2);
		let inc = Math.acos(Hk / h)*180/Math.PI;
		if (inc > 180) inc = 360 - inc;
		
		let Ni = -Hj;
		let Nj = Hi;
		let Nk = 0;
		
		let n = Math.sqrt(Ni**2 + Nj**2); // Nk is always 0, so don't bother with it here
		
		let omega_lon_asc = Math.acos(Ni / n)*180/Math.PI;
		if (Nj < 0) omega_lon_asc = 360 - omega_lon_asc;
		
		let NdotE = (Ni * Ei) + (Nj * Ej) + (Nk * Ek);
		let omega_arg_per = Math.acos(NdotE / (n * ecc))*180/Math.PI;
		if (Ek < 0) omega_arg_per = 360 - omega_arg_per;
		
		let EdotR = (Ei * Ri) + (Ej * Rj) + (Ek * Rk);
		let true_anomaly = Math.acos(EdotR / (ecc * R));
		if (RdotV < 0) true_anomaly = 2*Math.PI - true_anomaly;
		
		let mean_anomaly = Math.atan2(-Math.sqrt(1-ecc*ecc)*Math.sin(true_anomaly), -ecc - Math.cos(true_anomaly)) + Math.PI - ecc*(Math.sqrt(1-ecc*ecc)*Math.sin(true_anomaly)/(1+ecc*Math.cos(true_anomaly))); // stolen from wikipedieres
		
		let orbital_period = 2*Math.PI*Math.sqrt(sma**3/(G*(this.mass + this.parent.mass)));
		
		return [sma, ecc, inc, omega_arg_per, omega_lon_asc, mean_anomaly*180/Math.PI, true_anomaly*180/Math.PI, orbital_period];
	}
	
	// taken from stackoverflow: https://astronomy.stackexchange.com/questions/45456/how-to-translate-from-local-laplace-plane-to-ecliptic-j2000-or-icrf
	// transform vectors from icrf to local body frame (all z-up)
	icrf_to_ecliptic(ra, dec) {
		let x = this.pos[0]-this.parent.pos[0]; let y = this.pos[1]-this.parent.pos[1]; let z = this.pos[2]-this.parent.pos[2];
		let vx = this.vel[0]-this.parent.vel[0]; let vy = this.vel[1]-this.parent.vel[1]; let vz = this.vel[2]-this.parent.vel[2];
		//console.log(x,y,z);
		//console.log(vx,vy,vz);

		// rotate on z axis, -ra
		let x2 = x * Math.cos(-ra) - y * Math.sin(-ra);
		let vx2 = vx * Math.cos(-ra) - vy * Math.sin(-ra);
		let y2 = y * Math.cos(-ra) + x * Math.sin(-ra);
		let vy2 = vy * Math.cos(-ra) + vx * Math.sin(-ra);

		// rotate on y axis (dec - Math.PI / 2) must swap signs
		let angle = -dec + Math.PI / 2;
		let x3 = x2 * Math.cos(angle) - z * Math.sin(angle);
		let vx3 = vx2 * Math.cos(angle) - vz * Math.sin(angle);
		let z2 = z * Math.cos(angle) + x2 * Math.sin(angle);
		let vz2 = vz * Math.cos(angle) + vx2 * Math.sin(angle);

		x = x3;
		vx = vx3;
		y = y2;
		vy = vy2;
		z = z2;
		vz = vz2;

		//return {x, y, z, vx, vy, vz};
		this.pos = vec_add(this.parent.pos, [x,y,z]);
		this.vel = vec_add(this.parent.vel, [vx,vy,vz]);
		
		//console.log(x,y,z);
		//console.log(vx,vy,vz);
	}
	
	// code modified from orbitsimulator.com/gsim.html, line 9543: convertToEcliptic()
	convert_to_ecliptic(axial_tilt) {
		let e = Math.PI * axial_tilt / 180;

		let xeq = this.pos[0];
		let yeq = this.pos[1];
		let zeq = this.pos[2];

		let xec = xeq;
		let yec = yeq * Math.cos(e) + zeq * Math.sin(e);
		let zec = yeq * -Math.sin(e) + zeq * Math.cos(e);

		this.pos = [xec, yec, zec];
		
		xeq = this.vel[0];
		yeq = this.vel[1];
		zeq = this.vel[2];

		xec = xeq;
		yec = yeq * Math.cos(e) + zeq * Math.sin(e);
		zec = yeq * -Math.sin(e) + zeq * Math.cos(e);

		this.vel = [xec, yec, zec];
	}
}
let neutral_reference = new Object; // is this a neutral reference ?????????????????
neutral_reference.pos = [0,0,0];
neutral_reference.vel = [0,0,0];
let JD_epoch =(year, month, day, hour, minute=0, second=0, ms=0)=> {return new Date(year, month, day, hour, minute, second, ms);}
let J2000 = JD_epoch(2000, 0, 01, 12); // 2000, 0th month (January), 01st day, 12th hour, 00th minute 00th second, 0th millisecond.
// J2000.0 = 2451545 Julian Days
let J2000_epoch = J2000.getTime()/1000; // in seconds, instead of ms
let ceres_epoch = J2000.getTime()/1000 + (4856*24*60*60);
let NOW = Date.now()/1000; // check your clock, now :)
//NOW = J2000_epoch;
let au = 149597870691; // 149597870691 meters = 1 AU

let sun = new Body("Sun", "#ff0", 1.9885*10**30, 695700000, vec_mul([-5.689*10**5,1.113*10**6,3.476*10**3],1000), vec_mul([-1.446*10**-2,-3.456*10**-3,3.988*10**-4],1000));
sun.desc = "please ignore the funny math breaking above this textbox";
/*let sun2 = new Body("Sun 2", "#f00", 1.9885*10**30, 695700000, [0,0,0], [0,0,0]);
sun2.kepler(sun, 10000000222, 0, 0, 0, 0, 0);
let sun3 = new Body("Sun 3", "#0ff", 1.9885*10**30, 695700000, [0,0,0], [0,0,0]);
sun3.kepler(sun2, 10000000222, 0, 0, 0, 0, 0);
let sun4 = new Body("Sun 4", "#fff", 1.9885*10**30, 695700000, [0,0,0], [0,0,0]);
sun4.kepler(sun3, 10000000222, 0, 0, 0, 0, 0);*/
let earth = new Body("Earth", "#00f", 5.972168*10**24, 6371000, [152097597000,0,0], [0,-29782.7,0]);
earth.kepler(sun, 149598023000, 0.0167086, 0.00005/180*Math.PI, 114.20783/180*Math.PI, -11.26064/180*Math.PI, 358.617/180*Math.PI, NOW, J2000_epoch);//358.617/180*Math.PI);
earth.desc = "mostly harmless. please see back for details";
/*		Period		   1.0          // years
		SemiMajorAxis  1.0000010178 // a.u.
		Eccentricity   0.0167086342
		Inclination    0.0          // degrees
		AscendingNode  348.739      // degrees
		LongOfPericen  102.93734808 // degrees
		MeanLongitude  100.46645683 // degrees*/
let moon = new Body("Moon", "#aaa", 7.342*10**22, 1737400, [152097597000+405400000,0,0], [0,-29782.7-1022,0]);
moon.kepler(earth, 384399000, 0.0549, 5.145/180*Math.PI, 318.15/180*Math.PI, 125.08/180*Math.PI, 135.27/180*Math.PI, NOW, J2000_epoch);//135.27/180*Math.PI);
moon.desc = "the moon, also called selene, cynthia, e la lune, is made of cheese. it holds the record for being the biggest in comparison to its parent planet, at around 1/9th the radius of the earth.\n\nno es la locura,\nen realidad es el amor...";
//moon.convert_to_ecliptic(deg(23.4363051));
/*		Period          0.07480422854
		SemiMajorAxis   0.002537908496755768
		Eccentricity    0.0549
		Inclination     5.15
		MeanAnomaly     135.27
		AscendingNode   125.08
		ArgOfPericen    318.15*/
let venus = new Body("Venus", "#fa0", earth.mass*.815, 6052000, [0,0,0], [0,0,0]);
venus.kepler(sun, 0.7233*149597870691, 0.0068, 3.3947/180*Math.PI, (131.533-76.681)/180*Math.PI, 76.681/180*Math.PI, (181.979-131.533)/180*Math.PI, NOW, J2000_epoch);
venus.desc = "don't go here";
/*		Period          0.6152
		SemiMajorAxis   0.7233
		Eccentricity    0.0068
		Inclination     3.3947
		AscendingNode   76.681
		LongOfPericen   131.533
		MeanLongitude   181.979*/
let mercury = new Body("Mercury", "#777", earth.mass*.05528, 2440000, [0,0,0], [0,0,0]);
mercury.kepler(sun, 0.3871*149597870691, 0.2056, 7.0049/180*Math.PI, (77.456-48.33167)/180*Math.PI, 48.33167/180*Math.PI, (252.251-77.456)/180*Math.PI, NOW, J2000_epoch);
mercury.desc = "this is the closest planet to the sun! it may also have the shortest orbital period around the sun of any object in the entire solar system.";
/*		Period          0.2408
		SemiMajorAxis   0.3871
		Eccentricity    0.2056
		Inclination     7.0049
		AscendingNode   48.33167
		LongOfPericen   77.456
		MeanLongitude   252.251
		ArgOfPeriPreces 227000 // period of precession in years*/
/*moon.mass = earth.mass;
earth.vel[1] = -29782.7+700;
moon.vel[1] = -29782.7-700;*/
let mars = new Body("Mars","#f00", 6.4171*10**23, 3389500, [0,0,0], [0,0,0]);
mars.kepler(sun, 227939366000, 0.0934, 1.850/180*Math.PI, 286.5/180*Math.PI, 49.57854/180*Math.PI, 19.412/180*Math.PI, NOW, J2000_epoch);
mars.desc = "so-named for its bountiful mounds of cheap, easy-to-manufacture chocolate\n\nmountiful bounds";

let phobos = new Body("Phobos","#a00", 1.0659*10**16, 11266.7, [0,0,0], [0,0,0]);
phobos.kepler(mars, 9376000, 0.0151, 26.710/180*Math.PI, 92.19863/180*Math.PI, 82.8611/180*Math.PI, 0.00/180*Math.PI, /*NOW,*/ JD_epoch(2023, 3,11, 07,03,53,630).getTime()/1000, J2000_epoch);

//phobos.kepler(mars, 9376000, 0.0151, 1.093/180*Math.PI, deg(216.3), deg(169.2), deg(189.6), NOW, J2000_epoch);
//phobos.kepler(mars, 9376000, 0.0151, deg(1.093), 213.804/180*Math.PI, 128.694/180*Math.PI, 191.771/180*Math.PI, NOW, J2000_epoch);
//phobos.icrf_to_ecliptic(deg(317.7), deg(52.9));

let deimos = new Body("Deimos","#700", 1.4762*10**15, 6200, [0,0,0], [0,0,0]);
deimos.kepler(mars, 23463200, 0.00033, 25.8315/180*Math.PI, 92.1321/180*Math.PI, 82.7756/180*Math.PI, 0.00/180*Math.PI, /*NOW,*/ JD_epoch(2023, 3,10, 01,44,53,560).getTime()/1000, J2000_epoch);
deimos.desc = "wawawasdwasdAJwrna\nsfg gjeia jI Tjdwa\n\nd\na\ns";

//deimos.kepler(mars, 23463200, 0.00033, deg(1.8), deg(0.0), deg(54.4), deg(205.0), NOW, J2000_epoch)
//deimos.kepler(mars, 23463200, 0.00033, deg(1.793), 27.13/180*Math.PI, 271.725/180*Math.PI, 47.661/180*Math.PI, 21.087/180*Math.PI, NOW, JD_epoch(2023, 2, 3, 00));
//deimos.icrf_to_ecliptic(deg(316.7), deg(53.5))

// w is first, then OMEGA
let ceres = new Body("Ceres", "#aaa", earth.mass*.0001579, 470000, [0,0,0], [0,0,0]);
ceres.kepler(sun, 2.76799*au, 0.0761669, 10.5942/180*Math.PI, 72.1671/180*Math.PI, 80.3301/180*Math.PI, 327.854/180*Math.PI, NOW, ceres_epoch);
ceres.desc = "the largest of the celestial bodies in the asteroid belt. ceres is classified as a dwarf planet, actually!";
let pallas = new Body("Pallas", "#fff", earth.mass*.0000345, 263000, [0,0,0], [0,0,0]);
pallas.kepler(sun, 2.77202*au, 0.2315, 34.8368/180*Math.PI, deg(309.954), deg(173.12), deg(310.045), NOW, ceres_epoch); // pallas & ceres epoch are the same for some reason
let juno = new Body("Juno", "#aaf", earth.mass*4.722*10**-6, 130000, [0,0,0], [0,0,0]);
juno.kepler(sun, 2.67073*au, 0.255305, deg(12.9794), deg(248.31), deg(169.883), deg(257.639), NOW, ceres_epoch);
let vesta = new Body("Vesta", "#aa9", earth.mass*4.337*10**-5, 285000, [0,0,0], [0,0,0]);
vesta.kepler(sun, 2.36179*au, 0.08874, deg(7.14043), deg(151.19853), deg(103.85136), deg(20.86384), NOW, JD_epoch(2014, 11, 9, 00).getTime()/1000);

//let aethra = new Body("132 Aethra", "#f77", 10**18, 40000, [0,0,0], [0,0,0]);
//aethra.kepler(sun, 390050000000, 0.39036, deg(24.997), deg(255.216), deg(258.408), deg(38.271), NOW, JD_epoch(2016, 5, 31, 00).getTime()/1000);

let jupiter = new Body("Jupiter", "#faf", 1.8982*10**27, 69911000, [0,0,0], [0,0,0]);
jupiter.kepler(sun, 778.479*10**9, 0.0489, 1.303/180*Math.PI, 273.867/180*Math.PI, 100.464/180*Math.PI, 20.020/180*Math.PI, NOW, J2000_epoch);
jupiter.desc = "how jovial! and excessively huge!";
let io = new Body("Io", "#fa0", earth.mass*.01495, 1821600, [0,0,0], [0,0,0]);
io.kepler(jupiter, 421800000, 0.004, deg(0.0), deg(49.1), deg(0.0), deg(330.9), NOW, J2000_epoch);
let europa = new Body("Europa", "#fff", earth.mass*.008035, 1560800, [0,0,0], [0,0,0]);
europa.kepler(jupiter, 671100000, 0.0101, deg(0.47), deg(155.512-101.087), deg(101.087), deg(176.377-155.512), NOW, J2000_epoch);
let ganymede = new Body("Ganymede", "#c79", earth.mass*.0248, 2631200, [0,0,0], [0,0,0]);
ganymede.kepler(jupiter, 1070400000, 0.0015, deg(0.195), deg(188.831-119.841), deg(119.841), deg(121.206-188.831+360), NOW, J2000_epoch);
let callisto = new Body("Callisto", "#779", earth.mass*.0248, 2631200, [0,0,0], [0,0,0]);
callisto.kepler(jupiter, 1882700000, 0.007, deg(0.281), deg(335.933-323.265), deg(323.265), deg(85.091-335.933+360), NOW, J2000_epoch);
let amalthea = new Body("Amalthea", "#a50", earth.mass*3.515*10**-7, 83500, [0,0,0], [0,0,0], true);
amalthea.kepler(jupiter, 181400000, 0.003, deg(0.384285), deg(301.622765), deg(220.288958), deg(315.352094), NOW, J2000_epoch);
let thebe = new Body("Thebe", "#aaa", 4.3*10**17, 49300, [0,0,0], [0,0,0], true);
thebe.kepler(jupiter, 221900000, 0.0175, deg(1.1), deg(26.6), deg(340.4), deg(182.1), NOW, J2000_epoch);

let adrastea = new Body("Adrastea", "#999", 1, 1, [0,0,0], [0,0,0], true);
adrastea.kepler(jupiter, 129000000, 0.000, deg(0.0), deg(0.0), deg(0.0), deg(214.5), NOW, J2000_epoch);
let metis = new Body("Metis", "#666",1, 1, [0,0,0], [0,0,0], true);
metis.kepler(jupiter, 128000000, 0.000, deg(0.0), deg(0.0), deg(0.0), deg(166.0), NOW, J2000_epoch);

let himalia = new Body("Himalia", "#fff", 10**17, 12345);
himalia.tiny = true;
himalia.kepler(jupiter, 11440600000, 0.160, deg(28.1), deg(328.4), deg(68.2), deg(66.5), NOW, J2000_epoch); // this is the first ecliptic moon listed in https://ssd.jpl.nasa.gov/sats/elem/sep.html !!!!!!! hooray, it's accurate!!!

let elara = new Body("Elara", "#fff", 10**17, 12345);
elara.tiny = true;
elara.kepler(jupiter, 11712300000, 0.211, deg(27.9), deg(140.1), deg(118.1), deg(330.7), NOW, J2000_epoch);

let pasiphae = new Body("Pasiphae", "#fff", 10**17, 12345);
pasiphae.tiny = true;
pasiphae.kepler(jupiter, 23468200000, 0.412, deg(148.4), deg(264.8), deg(312.3), deg(277.8), NOW, J2000_epoch);

let sinope = new Body("Sinope", "#fff", 10**17, 12345);
sinope.tiny = true;
sinope.kepler(jupiter, 23683900000, 0.264, deg(157.3), deg(96.6), deg(304.6), deg(167.5), NOW, J2000_epoch);

//io.icrf_to_ecliptic(deg(268.1), deg(64.5));

let saturn = new Body("Saturn", "#ffa", earth.mass*95.162, 60268000, [0,0,0], [0,0,0]);
saturn.kepler(sun, 9.5371*au, 0.0542, 2.4845/180*Math.PI, (92.432-113.715+360)/180*Math.PI, 113.715/180*Math.PI, (49.944-92.432+360)/180*Math.PI, NOW, J2000_epoch);
saturn.desc = "the only planet in the solar system with rings trivially visible from earth. big rings. big gorgeous amazing beautiful magnificent wonderful rings. rings that could slice your home planet in twain, thus reducing the calcium industry to shambles. rubble even.";

let mimas = new Body("Mimas", "#888", 1, 1);
mimas.kepler(saturn, 186000000, 0.020, deg(1.6), deg(160.4), deg(66.2), deg(275.3), NOW, J2000_epoch);
let enceladus = new Body("Enceladus", "#fff", 1, 1);
enceladus.kepler(saturn, 238400000, 0.005, deg(0.0), deg(119.5), deg(0.0), deg(57.0), NOW, J2000_epoch);
let titan = new Body("Titan", "#ff0", 1.3452e+23, 2574730);
titan.kepler(saturn, 1221870000, 0.029, deg(0.3), deg(78.3), deg(78.6), deg(11.7), NOW, J2000_epoch);

// the georgium sidus, or just 'sidis'
let uranus = new Body("Uranus", "#0fa", earth.mass*14.536, 25362000);
uranus.kepler(sun, 19.19126*au, 0.04717, deg(0.773), deg(96.998857), deg(74.006), deg(142.238600), NOW, J2000_epoch);
uranus.desc = "uranus, also known as The Georgium Sidus and/or Urinus, is a big ball way out in space.";

let neptune = new Body("Neptune", "#0af", earth.mass*17.147, 24622000);
neptune.kepler(sun, 30.07*au, 0.008678, deg(1.770), deg(273.187), deg(131.783), deg(259.883), NOW, J2000_epoch);
neptune.desc = "the least moons of the giants, and the least-powerful winds.";

let pluto = new Body("Pluto", "#f7a", 1.303e+22, 1188300);
pluto.kepler(sun, 39.482*au, 0.2488, deg(17.16), deg(113.834), deg(110.299), deg(14.53), NOW, J2000_epoch);
pluto.desc = "even though it doesn't make categorical sense, the iau should've left pluto as an honorary/anachronistic planet\npluto is not an errant asteroid >:(";

let eris = new Body("Eris", "#577", 1.6*10**22, 1163000);
eris.kepler(sun, 67.864*au, 0.43607, deg(44.040), deg(151.639), deg(35.951), deg(205.989), NOW, JD_epoch(2020, 4, 31, 00).getTime()/1000);
eris.desc = "the discovery of eris, and the subsequent measurement of its radius, led to the declassification of pluto as a planet.\n\n\"betrayer of your own kind, eris\"";

let sedna = new Body("Sedna", "#f07", 10**22, 1000000);
sedna.kepler(sun, 506*au, 0.8496, deg(11.9307), deg(311.352), deg(144.248), deg(358.117), NOW, JD_epoch(2020, 4, 31, 00).getTime()/1000);
sedna.desc = "not much is known about sedna's physical characteristics!\nif new info comes out about its mass/radius, it will definitely be updated posthaste.";

//let comet = new Body("Comet", "#fff", 10**6, 1000, [1000000000000,0,0], [0,-2500,0]);
//comet.parent = sun;

let zoom = 1e-9;
function zoom_screen(event) {
	let change = 1 - (event.deltaY/1000);
	if (change < 0) return;
	zoom *= change;
	pan[0] *= change;
	pan[1] *= change;
	camera_clear_for_trails();
}
let active_keys = [];
window.addEventListener('keydown', function (e) {
	active_keys = (active_keys || []);
	active_keys[e.keyCode] = (e.type == "keydown");
});
window.addEventListener('keyup', function (e) {
	active_keys[e.keyCode] = (e.type == "keydown");            
});
canvas.addEventListener('mousedown', function (e) {
	if (focused_body == neutral_reference && hovered_body == neutral_reference) return; // prevents going from unfocused to unfocused, which is rather disorienting
	//if (focused_body != hovered_body) 
	if (hovered_body != neutral_reference) {
		pan = [0,0]; // if we're not looking at nothing (i.e., looking at a planet) then focus the camera at the center of the object of interest
	} else {
		let old_pan = [...pan];
		pan = vec_mul(focused_body.pos, -zoom); // if we suddenly ARE looking at nothing, then rearrange the camera to at least be where we were when we were where we where. this will not change the effective panning, but the trails should still be cleared; the focused body (or reference frame, whatevevr) has changed.
		pan = vec_add(old_pan, pan); // add the offset so that the camera is *never* jerked around without prior approval.
	}
	camera_clear_for_trails(); // if you're changing perspectives without changing the pan through the wasd or arrows, the camera needs to be cleared.
	focused_body = hovered_body; // focus on the darn thing you're hovering over
	hovered_body = neutral_reference; // forget i asked!
});
document.getElementById("info-body-desc").addEventListener('input', function (event) {
	focused_body.desc = document.getElementById("info-body-desc").value; // save and apply
});
document.getElementById("info-body-desc").addEventListener('focus', function (event) {
	GUI_desc_focused = true; // waow2
});
document.getElementById("info-body-desc").addEventListener('blur', function (event) {
	GUI_desc_focused = false; // waow
});
let paused = false;
document.getElementById("toggle-motion").addEventListener("click", (event)=>{
	paused = !paused;
	if (paused) {
		speed = 0;
	} else {
		speed = 100;
	}
});
let pan = [0,0];
let mouse_pos = [0,0];
let yz_rot = 0;
document.getElementById("yz-rot-setting").value = 0;
function update_mouse_pos(event) {
	//console.log(event.x+", "+event.y);
	//console.log(event);
	mouse_pos[0] = event.layerX - 1; // border of 1px
	mouse_pos[1] = event.layerY - 1;
}
let step = 1/60/100;//1e-4;
let speed = 100; // steps per loop
let time = 0; // in-simulation
let tick = 0; // no. of calls to loop
let trails = false;
let labels = true;
//trails=true;labels=false;step=3000;
let focused_body = neutral_reference;
let hovered_body = neutral_reference;

let GUI_last_focused_body = null;
let GUI_desc_focused = false;
//focused_body = mars; zoom *= 5000;// step = 10;
function draw_body(body, be_modular=false) {
	let onscreen_x = pan[0] + canvas.width/2 + (body.pos[0]-focused_body.pos[0])*zoom;
	let onscreen_y = pan[1] + canvas.height/2 + (body.pos[1]-focused_body.pos[1])*zoom*Math.cos(yz_rot) + (body.pos[2]-focused_body.pos[2])*zoom*Math.sin(yz_rot);
	let distance_to_parent = ((body.pos[0]-body.parent.pos[0])**2 + (body.pos[1]-body.parent.pos[1])**2 + (body.pos[2]-body.parent.pos[2])**2);
	if (((mouse_pos[0]-onscreen_x)**2 + (mouse_pos[1]-onscreen_y)**2) < (zoom*body.radius + 7)**2 &&
		(body.parent == neutral_reference || distance_to_parent*zoom*zoom > 256)) { // see the similar condition in draw_body_with_label
		hovered_body = body;
	} else {
		if (hovered_body == body) {hovered_body = neutral_reference;}
	}
	let scale = Math.max(zoom * body.radius, body.is_tiny ? 1 : 2);
	ctx.fillStyle = body.color;
	ctx.beginPath();
	ctx.arc(onscreen_x, onscreen_y, scale, 0, 2*Math.PI);
	ctx.fill();
	if (trails && body.id != focused_body.id) {
		ctx.beginPath();
		ctx.fillStyle = "#000";
		ctx.arc(onscreen_x, onscreen_y, scale-1, 0, 2*Math.PI);
		ctx.fill();
	}
	if (be_modular) {return [onscreen_x, onscreen_y, scale, distance_to_parent];}
}
function draw_body_with_label(body) {
	let info = draw_body(body, be_modular=true); // >>:(
	let onscreen_x = info[0];
	let onscreen_y = info[1];
	let scale = info[2];
	let distance_to_parent = info[3]
	if (labels) {
		if (body.parent == neutral_reference || distance_to_parent*zoom*zoom > 256) { // if the distance times the zoom is greater than 16, then the square distance times the zoom squared must be greater than 16**2, which is 256. if the parent is neutral, then no distance can be ascribed, so the object must always be labelled.
			if (trails) {
				ctx.font = "12px \"MS UI Gothic\"";
				let width = ctx.measureText(" "+body.name).width;
				ctx.fillStyle = "#000";
				ctx.fillRect(onscreen_x + scale, onscreen_y + scale/2, width, 13);
			}
			ctx.font = /*""+Math.floor(zoom)+*/"12px \"MS UI Gothic\""; // is PMingLiU-ExtB 12px the Elemental font?
			ctx.textAlign = "left";
			ctx.textBaseline = "top";
			ctx.fillStyle = body.color;
			ctx.fillText(" "+body.name, onscreen_x + scale, onscreen_y + scale/2);
		}
	}
}
function formatted_mass(mass) {
	let earth_mass = 5.972168*10**24;
	if (mass > earth_mass/100 && mass != earth.mass) {
		return Math.round((mass / earth.mass)*100000)/100000 + " earths";
	}
	else { // earth gets thrown in here so you can actually see what it is in-sim
		return Math.round(mass*10)/10 + "kg";
	}
}
function formatted_time(time) {
	let minutes = time/60;
	let hours = minutes/60;
	let days = hours/24; // JD, Julian Days
	let years = days/365.25; // JY, Julian Years(?)
	years = Math.floor(years);
	days = Math.floor(days%365.25);
	hours = Math.floor(hours)%24;
	minutes = Math.floor(minutes)%60;
	let seconds = (Math.round((time%60)*1000)/1000); // sorry for roundy decimal-pointy wackery
	let time_string = "";
	if (years > 0) time_string += years + "y ";
	if (days > 0 || years > 0) time_string += days + "d ";
	if (hours > 0 || days > 0 || years > 0) time_string += hours + "h ";
	time_string += minutes + "m " + seconds + "s";
	return time_string;
}
function formatted_dist(dist) {
	let distance = dist; // paranoia
	if (distance > au*.1) {distance /= au; distance = (Math.round(distance*10**8)/10**8) + 'au';}
	else {distance /= 1000; distance = Math.round(distance) + 'km';}
	return distance;
}
function draw() {
	/* * * display * * */
	
	if (!trails) ctx.clearRect(0, 0, canvas.width, canvas.height);
	for (let i = 0; i < bodies.length; i++) {
		let body = bodies[i];
		draw_body_with_label(body);
		/*let onscreen_x = pan[0] + canvas.width/2 + (body.pos[0]-focused_body.pos[0])*zoom;
		let onscreen_y = pan[1] + canvas.height/2 + (body.pos[1]-focused_body.pos[1])*zoom;
		let scale = Math.max(zoom * body.radius, 2);
		ctx.fillStyle = body.color;
		ctx.beginPath();
		ctx.arc(onscreen_x, onscreen_y, scale, 0, 2*Math.PI);
		ctx.fill();
		if (trails) {
			ctx.beginPath();
			ctx.fillStyle = "#000";
			ctx.arc(onscreen_x, onscreen_y, scale-1, 0, 2*Math.PI);
			ctx.fill();
			if (labels) {
				ctx.font = "12px \"MS UI Gothic\"";
				let width = ctx.measureText(" "+body.name).width;
				ctx.fillRect(onscreen_x + scale, onscreen_y + scale/2, width, 12);
			}
		}
		if (labels) {
			ctx.font = "12px \"MS UI Gothic\"";
			ctx.textAlign = "left";
			ctx.textBaseline = "top";
			ctx.fillStyle = body.color;
			ctx.fillText(" "+body.name, onscreen_x + scale, onscreen_y + scale/2);
		}*/
	}
	//window.requestAnimationFrame(draw);
}
//draw();
function camera_clear_for_trails() { // if the view/panning/zoom of the scene is changed, trails should be erased
	if (trails) {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
	}
}
function loop() {
	/* * * not display (camera panning) * * */
	if (!GUI_desc_focused/*not focusing textarea*/) {
		if (active_keys && (active_keys[37] || active_keys[65])) {pan[0] += 10; camera_clear_for_trails()}
		if (active_keys && (active_keys[39] || active_keys[68])) {pan[0] -= 10; camera_clear_for_trails()}
		if (active_keys && (active_keys[38] || active_keys[87])) {pan[1] += 10; camera_clear_for_trails()}
		if (active_keys && (active_keys[40] || active_keys[83])) {pan[1] -= 10; camera_clear_for_trails()}
		if (active_keys && active_keys[70]) {step *= 1.1;}
		if (active_keys && active_keys[82]) {step /= 1.1;}
	}
	
	/* * * settings * * */
	trails = document.getElementById("trails-setting").checked;
	let labels_setting_changed = document.getElementById("labels-setting").checked != labels;
	labels = document.getElementById("labels-setting").checked;
	
	let yz_rot_setting_value = document.getElementById("yz-rot-setting").value/100*Math.PI*2;
	if (yz_rot_setting_value != yz_rot) {
		yz_rot = yz_rot_setting_value;
		document.getElementById("yz-rot-indicator").innerHTML = "&emsp;"+(yz_rot+'').substr(0,4)+" rad";
		camera_clear_for_trails();
	}
	
	/* * * extra thing for trails+labels * * */
	if (labels && trails || labels_setting_changed) {
		for (let i = 0; i < bodies.length; i++) {
			let body = bodies[i];
			let distance_to_parent = ((body.pos[0]-body.parent.pos[0])**2 + (body.pos[1]-body.parent.pos[1])**2 + (body.pos[2]-body.parent.pos[2])**2);
			if (body.parent == neutral_reference || distance_to_parent*zoom*zoom > 16*16) {
				let onscreen_x = pan[0] + canvas.width/2 + (body.pos[0]-focused_body.pos[0])*zoom;
				let onscreen_y = pan[1] + canvas.height/2 + (body.pos[1]-focused_body.pos[1])*zoom*Math.cos(yz_rot) + (body.pos[2]-focused_body.pos[2])*zoom*Math.sin(yz_rot);
				let scale = Math.max(zoom * body.radius, 2);
				ctx.fillStyle = "#000";
				ctx.beginPath();
				ctx.font = "12px \"MS UI Gothic\"";
				let width = ctx.measureText(" "+body.name).width;
				ctx.fillRect(onscreen_x + scale, onscreen_y + scale/2, width, 13);
			}
		}
	}
	
	/* * * STEP * * */
	for (let S = 0; S < speed; S++) {
	
		for (let i = 0; i < bodies.length; i++) {
			let body = bodies[i];
			for (let j = 0; j < bodies.length; j++) {
				if (bodies[j] == body) {/* do nothing for this loop please thank you */
				} else {
					let other = bodies[j];
					let vec = vec_sub(other.pos, body.pos);
					let r = (vec[0]**2 + vec[1]**2 + vec[2]**2)**.5;
					vec = vec_div(vec, r); // normalize?
					let F = G * (body.mass * other.mass) / r**2; // G*(m1m2/r^2)
					vec = vec_mul(vec, F*step/body.mass);
					body.vel = vec_add(body.vel, vec);
				}
			}
		}
		
		for (let i = 0; i < bodies.length; i++) {
			let body = bodies[i];
			body.pos = vec_add(body.pos, vec_mul(body.vel, step));
			if (trails && S % 15 == 0) draw_body(bodies[i]);
		}
		
		/*for (let i = 0; i < bodies.length; i++) { // bluh (this is irreducible because if you merged it with the pos-updating loop, objects would be drawn where they technically never were in relation to each other. same goes for pos to vel-updating; essentially these all have to be buffers of each other, which is terrible.)
			if (trails && S % 5 == 0) draw_body(bodies[i]);
		}*/
		
	}
	
	time += step * speed; // keep in step!
	tick++;
	draw(); // listen i know this distinction is silly but i want the other stuff to work even if nothing is being drawn to the canvas xdd
	let current_moment = new Date(Date.now());
	let simulation_moment = new Date(1000*(NOW+time));
	let current_epoch = 2451545 + (simulation_moment.getTime()/1000 - J2000_epoch)/86400;
	document.getElementById("simulation-time-indicator").innerHTML = simulation_moment;//.toUTCString();
	if (GUI_last_focused_body != focused_body) { // aka, on hovered_body change do:
		GUI_last_focused_body = focused_body;
		if (focused_body == neutral_reference) {
			document.getElementById("info-floating").classList.remove("hidden");
			document.getElementById("info-body").classList.add("hidden");
		}
		else {
			document.getElementById("info-floating").classList.add("hidden");
			document.getElementById("info-body").classList.remove("hidden");
			
			document.getElementById("info-body-desc").value = focused_body.desc; // update the description box :3
		}
	}
	if (focused_body != neutral_reference) {
		let body_info = focused_body.get_osculating_elements();
		for (let i = 0; i < body_info.length; i++) {body_info[i]*=10**8; body_info[i] = Math.round(body_info[i]); body_info[i]/=10**8;}
		let sma = body_info[0];
		if (sma > au*.1) {sma /= au; sma = (Math.round(sma*10**8)/10**8) + 'au';}
		else {sma /= 1000; sma = Math.round(sma) + 'km';}
		let speed = Math.sqrt(focused_body.vel[0]**2 + focused_body.vel[1]**2 + focused_body.vel[2]**2);
		let relative_speed = Math.sqrt((focused_body.vel[0]-focused_body.parent.vel[0])**2 + (focused_body.vel[1]-focused_body.parent.vel[1])**2 + (focused_body.vel[2]-focused_body.parent.vel[2])**2);
		
		document.getElementById("info-body-radius").innerHTML = Math.floor(focused_body.radius/1000) + "km";
		document.getElementById("info-body-mass").innerHTML = formatted_mass(focused_body.mass);
		document.getElementById("info-body-color").innerHTML = focused_body.color;
		
		document.getElementById("info-body-name").innerHTML = focused_body.name;
		document.getElementById("info-body-parent").innerHTML = focused_body.parent.name;
		document.getElementById("info-body-epoch").innerHTML = "JD" + current_epoch;
		document.getElementById("info-body-sma").innerHTML = formatted_dist(body_info[0]);
		document.getElementById("info-body-ecc").innerHTML = body_info[1] + "";
		document.getElementById("info-body-inc").innerHTML = body_info[2] + "&deg;";
		document.getElementById("info-body-arg-per").innerHTML = body_info[3] + "&deg;";
		document.getElementById("info-body-lon-asc").innerHTML = body_info[4] + "&deg;";
		document.getElementById("info-body-mean-anomaly").innerHTML = body_info[5] + "&deg;";
		document.getElementById("info-body-true-anomaly").innerHTML = body_info[6] + "&deg;";
		document.getElementById("info-body-orbital-period").innerHTML = formatted_time(body_info[7]);
		document.getElementById("info-body-speed").innerHTML = Math.round(speed*1000)/1000 + "m/s";
		document.getElementById("info-body-relative-speed").innerHTML = Math.round(relative_speed*1000)/1000 + "m/s";
		document.getElementById("info-body-distance-to-parent").innerHTML = formatted_dist(((focused_body.pos[0]-focused_body.parent.pos[0])**2 + (focused_body.pos[1]-focused_body.parent.pos[1])**2 + (focused_body.pos[2]-focused_body.parent.pos[2])**2)**.5);
	}
	
	/*if (!paused)*/ window.requestAnimationFrame(loop);
}
document.getElementById("labels-setting").checked = true;
loop();
</script>
</body>
</html>