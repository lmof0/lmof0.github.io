<!doctype html>
<html>
<head>
<title>a website: blocks</title>
<style>

</style>
</head>
<body>
<canvas width="600" height="480" id="canvas"></canvas><br>
hey i heard you like webgl draw calls
<script id="vertex-shader" type="notjs">
	attribute vec4 a_position;
	attribute vec4 a_color; // input from the cpu
	
	uniform mat4 u_matrix;
	
	varying vec4 v_color; // input from the vertex shader, exclusively for the fragment shader, which is the only thing that can do anything with color

	void main() {
		gl_Position = u_matrix * a_position;
		v_color = a_color;
	}
</script>
<script id="fragment-shader" type="notjs">
	precision mediump float;
	
	varying vec4 v_color;
	
	void main() {
		gl_FragColor = v_color;
	}
</script>
</body>
<script src="matrixutils.js"></script>
<script>
let canvas = document.getElementById("canvas");
let gl = canvas.getContext("webgl");
if (!gl) console.log("you are slime");

function createShader(gl, type, source) {
	let shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
	if (success) {
		return shader;
	}
	
	console.log(gl.getShaderInfoLog(shader));
	gl.deleteShader(shader);
}
let vertexShaderSource = document.querySelector("#vertex-shader").text;
let fragmentShaderSource = document.querySelector("#fragment-shader").text;

let vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
let fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);

function createProgram(gl, vertexShader, fragmentShader) {
	let program = gl.createProgram();
	gl.attachShader(program, vertexShader);
	gl.attachShader(program, fragmentShader);
	gl.linkProgram(program);
	let success = gl.getProgramParameter(program, gl.LINK_STATUS);
	if (success) return program;
	
	console.log(gl.getProgramInfoLog(program));
	gl.deleteProgram(program);
}
let program = createProgram(gl, vertexShader, fragmentShader);

let positionLocation = gl.getAttribLocation(program, "a_position");
let colorLocation =  gl.getAttribLocation(program, "a_color");

let matrixLocation = gl.getUniformLocation(program, "u_matrix");

let cube_verts = [
	[0,0,0],
	[1,0,0],
	[1,1,0],
	[0,1,0],
	[0,0,1],
	[1,0,1],
	[1,1,1],
	[0,1,1]
];
let cube_tris = [
	// Back, Front, Top, Bottom, Left, Right
	// 0 1 2 2 1 3
	[0, 3, 1, 2], // Back Face
	[5, 6, 4, 7], // Front Face
	[3, 7, 2, 6], // Top Face
	[1, 5, 0, 4], // Bottom Face
	[4, 7, 0, 3], // Left Face
	[1, 2, 5, 6]  // Right Face
];
let positions = [];
let colors = [];
for (let i = 0; i < 6; i++) {
	let face = cube_tris[i];
	let tris = [];
	tris.push(face[0], face[1], face[2],
			  face[2], face[1], face[3]);
	let verts = [];
	tris.forEach((i)=>{
		let vertex = cube_verts[i];
		verts.push(vertex[0], vertex[1], vertex[2]); // god please forgive me
	});
	//let tri_1 = [...face].splice(0,3);
	//let tri_2 = [...face].splice(1,3);
	verts.forEach((i)=>{ positions.push((i-0.5)*2); });
	colors.push(200, 70, 120, 255);
}
colors = positions; // what. why.
let positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

let colorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Uint8Array(colors), gl.STATIC_DRAW);

let camera_pan = [0,0,0];
let camera_rot = [0,0,0];
let camera_scale = [1,1,1];
let t = 0;
function draw() {
	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
	
	gl.clearColor(0, 0, 0, 0);
	
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.enable(gl.CULL_FACE);
	
	gl.useProgram(program);
	
	gl.enableVertexAttribArray(positionLocation);
	
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

	let size = 3;
	let type = gl.FLOAT;
	let normalize = false;
	let stride = 0;
	let offset = 0;
	gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
	
	gl.enableVertexAttribArray(colorLocation);
	
	gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
	
	size = 3;
	type = gl.UNSIGNED_BYTE;
	normalize = true;
	stride = 0;
	offset = 0;
	gl.vertexAttribPointer(colorLocation, size, type, normalize, stride, offset);
	
	let aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	let zNear = 1;
	let zFar = 2000;
	let matrix = m4.perspective(1, aspect, zNear, zFar);
	//let matrix = m4.projection(gl.canvas.clientWidth, gl.canvas.clientHeight, 400);
	matrix = m4.translate(matrix, camera_pan[0], camera_pan[1], camera_pan[2]);
	matrix = m4.xRotate(matrix, camera_rot[0]);
    matrix = m4.yRotate(matrix, camera_rot[1]);
    matrix = m4.zRotate(matrix, camera_rot[2]);
    matrix = m4.scale(matrix, camera_scale[0], camera_scale[1], camera_scale[2]);
	
	gl.uniformMatrix4fv(matrixLocation, false, matrix);
	
	let primitiveType = gl.TRIANGLES;
	offset = 0;
	let count = 36; // 12 tris in a cube, 36 verts
	gl.drawArrays(primitiveType, offset, count);
	camera_pan = [0, 0, -10];
	t+=0.01
	camera_rot = [3*t,2*t,t];
	window.requestAnimationFrame(draw);
}
draw();
class Block {
	constructor(name, tex) {
		this.name = name;
		this.tex = tex;
	}
}
const Blocks = {
	AIR: new Block("Air", [0,0]),
	STONE: new Block("Stone", [0,0])
}
class Chunk {
	constructor() {
		//this.blockdata = new Array(16*128*16).fill(1);//x*y*z
		
	}
}
class World {
	constructor() {
		
	}
}
</script>
</html>